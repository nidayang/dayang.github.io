<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>创建型设计模式之单例设计模式</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.9825735b.css" as="style"><link rel="preload" href="/assets/js/app.dec1967b.js" as="script"><link rel="preload" href="/assets/js/2.9efafe32.js" as="script"><link rel="preload" href="/assets/js/9.5bfd371b.js" as="script"><link rel="prefetch" href="/assets/js/10.075c937d.js"><link rel="prefetch" href="/assets/js/11.9f783c45.js"><link rel="prefetch" href="/assets/js/12.028f3a58.js"><link rel="prefetch" href="/assets/js/13.911bd29d.js"><link rel="prefetch" href="/assets/js/14.0f912e52.js"><link rel="prefetch" href="/assets/js/15.be8d5516.js"><link rel="prefetch" href="/assets/js/16.0c8303bd.js"><link rel="prefetch" href="/assets/js/3.89a35d8a.js"><link rel="prefetch" href="/assets/js/4.6e92b036.js"><link rel="prefetch" href="/assets/js/5.4d3a910a.js"><link rel="prefetch" href="/assets/js/6.b62b23e4.js"><link rel="prefetch" href="/assets/js/7.4fb8bec6.js"><link rel="prefetch" href="/assets/js/8.80acf0fe.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9825735b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>创建型设计模式之单例设计模式</span> <!----></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="创建型设计模式之单例设计模式"><a href="#创建型设计模式之单例设计模式" class="header-anchor">#</a> 创建型设计模式之单例设计模式</h1> <h3 id="_1-单例的定义"><a href="#_1-单例的定义" class="header-anchor">#</a> 1.单例的定义</h3> <p>**单例模式（单间模式）😗*确保一个类只有一个实例，并提供一个全局的访问点。</p> <h3 id="_2-单例的由来"><a href="#_2-单例的由来" class="header-anchor">#</a> 2.单例的由来</h3> <h4 id="_2-1-产生原因"><a href="#_2-1-产生原因" class="header-anchor">#</a> 2.1 产生原因</h4> <p>就是说很多重要的对象，整个程序的全局中只需要一个就行了，比如线程池、缓存、注册表等等对象。如果说你 new 了多个这种对象，就会导致程序异常或者说是意想不到的结果。</p> <h4 id="_2-2-形象比喻"><a href="#_2-2-形象比喻" class="header-anchor">#</a> 2.2 形象比喻</h4> <p>就拿我们自己的屋子比作一个程序，屋子里的任何东西都想象成对象。那你就该想到屋子里有一些的对象只要有一个就行了，往大了说一个厨房、一个浴室，往小了说马桶、椅子。就拿这个马桶来说事，我们拉屎就得去厕所中用马桶这个对象 ，而不是你们说的 **诶我就牛逼我就是阿拉丁，我 tm 裤子一脱屁股一蹲，就能 new 出一个马桶对象来给我用。**我只想说，好家伙好家伙牛逼牛逼。但是这个屋子还能叫屋子吗，没有规矩，欸我随便在哪里都能直接桌下拉屎，这显然不合理。当然，这边只不过是一个形象的比喻，其实屋子里的任何一件东西都是单例的，都是独一无二的。</p> <h4 id="_2-3-替代方法以及为何不使用替代的方法"><a href="#_2-3-替代方法以及为何不使用替代的方法" class="header-anchor">#</a> 2.3 替代方法以及为何不使用替代的方法</h4> <p>大家这边或许有疑问，那我们大家<strong>约定</strong>好使用这些重要对象的注意事项，或者我们大家使用静态的<strong>全局变量</strong>，</p> <p>不是可以替代上面的单例设计模式吗？？？</p> <h5 id="_2-3-1-解答"><a href="#_2-3-1-解答" class="header-anchor">#</a> 2.3.1 解答</h5> <p>首先，大家一起约定好不现实，一个系统总会有换人的时候，总会有断档的时候，有时候口头上的约定不如代码来的现实。其次，全局变量确实可以做到这一点，但如果说系统从头到尾都没有使用这个全局变量，就会产生浪费资源的情况。当然，用的好的话，全局的静态变量、静态方法那是可以用的。只不过多了解一个设计模式不是更好吗！！！</p> <h3 id="_3-单例的代码"><a href="#_3-单例的代码" class="header-anchor">#</a> 3.单例的代码</h3> <h4 id="_3-1饿汉式-静态常量"><a href="#_3-1饿汉式-静态常量" class="header-anchor">#</a> 3.1<strong>饿汉式（静态常量）</strong></h4> <p>实现步骤:</p> <ul><li>构造器私有化 (防止 new )</li> <li>类的内部创建对象</li> <li>向外暴露一个静态的公共方法 getInstance （）</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType1</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token class-name">SingletonType1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType1</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonType1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SingletonType1</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>优缺点：</strong></p> <ul><li>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。</li> <li>缺点：
<ul><li>在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费</li> <li>这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载 时就实例化，在单例模式中大多数都是调用 getInstance 方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化 instance 就没有达到 lazy loading 的效果</li></ul></li> <li>结论：这种单例模式可用，可能造成内存浪费</li></ul> <h4 id="_3-2饿汉式-静态代码块"><a href="#_3-2饿汉式-静态代码块" class="header-anchor">#</a> 3.2<strong>饿汉式（静态代码块）</strong></h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType2</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType2</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        instance  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonType2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token class-name">SingletonType2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType2</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>**优缺点说明：**这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p> <p>**结论：**这种单例模式可用，但是可能造成内存浪费</p> <h4 id="_3-3懒汉式线程不安全"><a href="#_3-3懒汉式线程不安全" class="header-anchor">#</a> 3.3<strong>懒汉式线程不安全</strong></h4> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">singleton</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * @author DAYANG
 * @ClassName Singleton
 * @Description
 * @Date 2021/6/30 23:17
 * @Version 1.0.0
 **/</span>

<span class="token comment">//延迟加载的原生的单例的设计模式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

</code></pre></div><h5 id="_3-1-1-原理"><a href="#_3-1-1-原理" class="header-anchor">#</a> 3.1.1 原理</h5> <ul><li>想要只有一个对象---&gt;其他地方不能 new 这个对象---&gt;<strong>把构造器私有化</strong></li> <li>构造器私有化后这个对象如何产生---&gt;自己内部产生</li> <li>如何给外部提供对象---&gt;用一个静态的方法和静态的变量，静态方法用于产生对象，静态的变量用于承载这个对象</li> <li>外部对象如何获得---&gt;通过类名直接调用这个静态的方法获得这个对象。</li></ul> <h5 id="_3-1-2-介绍与问题"><a href="#_3-1-2-介绍与问题" class="header-anchor">#</a> 3.1.2 介绍与问题</h5> <p>简介：这是一个延迟加载的设计模式，只有调用才会产生这个对象</p> <p>问题：资源只有一个资源，当有多个线程同时访问这个静态的方法的时候，就会产生同步的问题。最不能容忍的就是多线程调用方法产生的对象不是同一个对象，那这个单例类就失去了意义。</p> <h5 id="_3-1-3-解决多线程的问题"><a href="#_3-1-3-解决多线程的问题" class="header-anchor">#</a> 3.1.3 解决多线程的问题</h5> <ul><li>方式一：加一个同步锁 synchronized，想一想这样就出现了俩个问题。第一就是慢，第二就是这边也不是每次都要同步，也就是生成对象的那第一次需要同步，其他的时候都不会产生多线程的问题。</li></ul> <h4 id="_3-4懒汉式线程安全-同步方法"><a href="#_3-4懒汉式线程安全-同步方法" class="header-anchor">#</a> 3.4<strong>懒汉式线程安全（同步方法）</strong></h4> <p><strong>代码：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType4</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType4</span> singleton<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">SingletonType4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">SingletonType4</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonType4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>优缺点说明：</strong></p> <ul><li>解决了线程不安全问题</li> <li>效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接 return 就行了。方法进行同步效率太低</li> <li>结论：<strong>在实际开发中，不推荐使用这种方式</strong></li></ul> <h4 id="_3-5懒汉式线程安全-同步代码块"><a href="#_3-5懒汉式线程安全-同步代码块" class="header-anchor">#</a> 3.5<strong>懒汉式线程安全（同步代码块）</strong></h4> <p><strong>代码：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType5</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType5</span> singleton<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">SingletonType5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType5</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SingletonType5</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonType5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>优缺点说明：</strong></p> <ul><li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低， 改为同步产生实例化的的代码块</li> <li>但是这种同步并不能起到线程同步的作用。跟第 3 种实现方式遇到的情形一 致，假如一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行， 另一个线程也通过了这个判断语句，这时便会产生多个实例</li> <li>结论：<strong>在实际开发中，不能使用这种方式</strong></li></ul> <h4 id="_3-6懒汉式线程安全-双重检查"><a href="#_3-6懒汉式线程安全-双重检查" class="header-anchor">#</a> 3.6<strong>懒汉式线程安全（双重检查）</strong></h4> <p><strong>代码：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType6</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType6</span> singleton<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">SingletonType6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingletonType6</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">SingletonType6</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonType6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>优缺点说明：</strong></p> <ul><li>Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次 if (singleton == null)检查，这样就可以保证线程安全了。</li> <li>这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)， 直接 return 实例化对象，也避免的反复进行方法同步.</li> <li>线程安全；延迟加载；效率较高</li> <li>结论：<strong>在实际开发中，推荐使用这种单例设计模式</strong></li></ul> <h4 id="_3-7懒汉式线程安全-静态内部类"><a href="#_3-7懒汉式线程安全-静态内部类" class="header-anchor">#</a> 3.7<strong>懒汉式线程安全（静态内部类）</strong></h4> <p><strong>代码：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType7</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">SingletonType7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SingletonType7</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonType7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">SingletonType7</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>优缺点说明：</strong></p> <ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</li> <li>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化 时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的 实例化,<strong>相较于饿汉式效率较高</strong></li> <li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li> <li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li> <li>结论：<strong>推荐使用</strong></li></ul> <h4 id="_3-8通过枚举的方式实现单例"><a href="#_3-8通过枚举的方式实现单例" class="header-anchor">#</a> 3.8<strong>通过枚举的方式实现单例</strong></h4> <p><strong>代码：</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonType8</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Singleton</span> instance1 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
        <span class="token class-name">Singleton</span> instance2 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance1 <span class="token operator">==</span> instance2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">enum</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>
 INSTANCE<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>优缺点说明：</strong></p> <ul><li>这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能<strong>防止反序列化重新创建新的对象</strong>。</li> <li>这种方式是 Effective Java 作者 Josh Bloch <strong>提倡的方式</strong></li> <li>结论：<strong>推荐使用</strong></li></ul> <h4 id="_4-jdk-中的使用"><a href="#_4-jdk-中的使用" class="header-anchor">#</a> 4.jdk 中的使用</h4> <p><strong>java.lang.Runtime 就是经典的单例模式(饿汉式)</strong></p> <p><img src="https://dyimgstorage-1304967922.cos.ap-nanjing.myqcloud.com/mdimg/202109181610995.png" alt="image-20210918161018296"></p> <h4 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5.总结</h4> <p><strong>单例模式注意事项和细节说明</strong></p> <ul><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，<strong>对于一些需 要频繁创建销毁的对象</strong>，使用单例模式可以提高系统性能</li> <li>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使 用 new</li> <li>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即：<strong>重量级对象</strong>)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session 工厂等)</li></ul> <p><strong>单例模式各种不同实现方式的使用推荐</strong>（加粗的表示推荐）</p> <ul><li><strong><em>饿汉式(静态常量)</em></strong></li> <li><strong><em>饿汉式（静态代码块）</em></strong></li> <li>懒汉式(线程不安全)</li> <li>懒汉式(线程安全，同步方法)</li> <li>懒汉式(线程安全，同步代码块)</li> <li><strong><em>双重检查</em></strong></li> <li><strong><em>静态内部类</em></strong></li> <li><strong><em>枚举</em></strong></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.dec1967b.js" defer></script><script src="/assets/js/2.9efafe32.js" defer></script><script src="/assets/js/9.5bfd371b.js" defer></script>
  </body>
</html>
